// Copyright (c) 2025 Morgan Skillicorn. All rights reserved.


#include "HapiContainer.h"

UHapiContainer::UHapiContainer(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    AssetWrapper = nullptr;
    TestHDA = nullptr;
    CubesToSpawn = 10;
}

#if WITH_EDITOR
FString UHapiContainer::StartHapi()
{
    FString output = "";

    if (API != nullptr)
    {
        if (!API->IsSessionValid())
        {
            UE_LOG(LogTemp, Warning, TEXT("Creating HAPI session."));
            output = "Creating HAPI session.";
            API->CreateSession();
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("HAPI session already exists!"));
            output = "HAPI session already exists!";
        }
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("HAPI could not be found."));
        output = "HAPI could not be found.";
    }

    return output;
}

bool UHapiContainer::IsHapiServerRunning() const
{
    return API && API->IsSessionValid();
}

void UHapiContainer::TestInput()
{
    UHoudiniAsset* const ExampleHDA = TestHDA;
    AssetWrapper = API->InstantiateAsset(ExampleHDA, FTransform::Identity);

    if (IsValid(AssetWrapper))
    {
        // Pre-instantiation is the earliest point where parameter values can be set
        AssetWrapper->GetOnPreInstantiationDelegate().AddUniqueDynamic(this, &UHapiContainer::SetInitialParameterValues);
        // Inputs are only available after instantiation
        AssetWrapper->GetOnPostInstantiationDelegate().AddUniqueDynamic(this, &UHapiContainer::SetInputs);
        // Print the outputs after the node has cook and the plug-in has processed the output
        AssetWrapper->GetOnPostProcessingDelegate().AddUniqueDynamic(this, &UHapiContainer::PrintOutputs);
        // Bake the Houdini cook and remove proxy geo
        AssetWrapper->GetOnPostProcessingDelegate().AddUniqueDynamic(this, &UHapiContainer::BakeOutputs);
    }
}

void UHapiContainer::SetInitialParameterValues_Implementation(UHoudiniPublicAPIAssetWrapper* InWrapper)
{
    // Pass an input parameter to the HDA
    InWrapper->SetIntParameterValue(TEXT("test"), CubesToSpawn);
    // We have set the initial values and can unbind from the delegate
    InWrapper->GetOnPreInstantiationDelegate().RemoveDynamic(this, &UHapiContainer::SetInitialParameterValues);
}

void UHapiContainer::SetInputs_Implementation(UHoudiniPublicAPIAssetWrapper* InWrapper)
{
    // Since we are done with setting the initial values, we can unbind from the delegate
    InWrapper->GetOnPostInstantiationDelegate().RemoveDynamic(this, &UHapiContainer::SetInputs);
}

void UHapiContainer::PrintOutputs_Implementation(UHoudiniPublicAPIAssetWrapper* InWrapper)
{
    // Print out all outputs generated by the HDA
    const int32 NumOutputs = InWrapper->GetNumOutputs();
    UE_LOG(LogTemp, Log, TEXT("NumOutputs: %d"), NumOutputs);
    if (NumOutputs > 0)
    {
        for (int32 OutputIndex = 0; OutputIndex < NumOutputs; ++OutputIndex)
        {
            TArray<FHoudiniPublicAPIOutputObjectIdentifier> Identifiers;
            InWrapper->GetOutputIdentifiersAt(OutputIndex, Identifiers);

            UE_LOG(LogTemp, Log, TEXT("\toutput index: %d"), OutputIndex);
            UE_LOG(LogTemp, Log, TEXT("\toutput type: %d"), InWrapper->GetOutputTypeAt(OutputIndex));
            UE_LOG(LogTemp, Log, TEXT("\tnum_output_objects: %d"), Identifiers.Num());

            if (Identifiers.Num() > 0)
            {
                for (const FHoudiniPublicAPIOutputObjectIdentifier& Identifier : Identifiers)
                {
                    UObject* const OutputObject = InWrapper->GetOutputObjectAt(OutputIndex, Identifier);
                    UObject* const OutputComponent = InWrapper->GetOutputComponentAt(OutputIndex, Identifier);
                    const bool bIsProxy = InWrapper->IsOutputCurrentProxyAt(OutputIndex, Identifier);

                    UE_LOG(LogTemp, Log, TEXT("\t\tidentifier: %s_%s"), *(Identifier.PartName), *(Identifier.SplitIdentifier));
                    UE_LOG(LogTemp, Log, TEXT("\t\toutput_object: %s"), IsValid(OutputObject) ? *(OutputObject->GetFName().ToString()) : TEXT("None"))
                    UE_LOG(LogTemp, Log, TEXT("\t\toutput_component: %s"), IsValid(OutputComponent) ? *(OutputComponent->GetFName().ToString()) : TEXT("None"))
                    UE_LOG(LogTemp, Log, TEXT("\t\tis_proxy: %d"), bIsProxy)
                    UE_LOG(LogTemp, Log, TEXT(""))
                }
            }
        }
    }
}

void UHapiContainer::BakeOutputs_Implementation(UHoudiniPublicAPIAssetWrapper* InWrapper)
{
    if (!InWrapper)
    {
        UE_LOG(LogTemp, Warning, TEXT("BakeOutputs called with null AssetWrapper"));
        return;
    }

    // Dispatch BakeAllOutputs on Game Thread
    AsyncTask(ENamedThreads::GameThread, [InWrapper]()
    {
        InWrapper->SetBakeMethod(EHoudiniEngineBakeOption::ToActor);
        InWrapper->SetRemoveOutputAfterBake(true);
        InWrapper->SetRecenterBakedActors(false);
        InWrapper->SetReplacePreviousBake(true);

        bool bSuccess = InWrapper->BakeAllOutputs();

        if (bSuccess)
        {
            UE_LOG(LogTemp, Log, TEXT("BakeAllOutputs succeeded."));
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("BakeAllOutputs failed."));
        }
    });
}

#endif
